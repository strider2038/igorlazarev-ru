---
title: 'Как DeepSeek помог мне быстро решить задачу по метрикам'
slug: 'deepseek-experience'
date: '2025-03-26T20:20:00+03:00'
category: "Нейросети"
tags: ["LLM", "deepseek", "grafana", "prometheus"]
image: 'poster.jpg'
---

Постепенно внедряю в свою жизнь как разработчика работу с популярными нейросетями. До этого
момента в основном AI-инструменты использовал как "помогаторы" в написании кода (подсказчики типа
[Codeium](https://codeium.com/)), или для получения краткой выжимки по каким-то статьям или темам
(нейро вкладка в Яндекс-поиске). Непосредственно чат-ботами с точки зрения практики пользовался редко, 
т.к. чаще всего непонятно а что их спрашивать-то? По специфическим вопросам пока они помогают
не особо успешно (по экзотическим SQL запросам, например). В основном все равно приходится идти через документацию
или ориентироваться на свои знания и опыт. Пару раз задавал вопросы по незнакомым мне темам (о строительстве, например)
и в целом получал хорошие ответы.

Но тут на работе возникла такая потребность - нужно на основе метрик [Prometheus](https://prometheus.io/)
и [Grafana](https://grafana.com/) найти наиболее медленные endpoint'ы и сделать по ним дашборд. Сначала
пошел по привычному пути - через поисковик. 15-20 минут работы в поисковике и выборки статей не особо помогли
приблизиться к цели. Обычно дальше уже начинает подробнее разбирать документацию и на это уходит куча времени.
Поэтому отложил задачу в долгий ящик. А на днях решил попробовать адресовать эту задачу [DeepSeek](https://deepseek.io/).
Сформировал такой запрос.

> Как построить графики для Grafana и Prometheus которые показывали бы наиболее медленные endpoint'ы 
> по среднему времени ответа за день?

И к моему удивлению примерно за минуту получил лаконичный, довольно точный ответ, да еще и с рекомендациями
по возможным оптимизациям. Далее минут за 15 добавил дашборд и доработал визуальную составляющую под свой вкус.

Далее просто приведу ответ DeepSeek на свой вопрос.

---

Чтобы построить графики в Grafana и Prometheus, отображающие самые медленные эндпоинты по среднему времени ответа за день, выполните следующие шаги:

---

### 1. **Настройка метрик в приложении**
Убедитесь, что ваше приложение экспортирует метрики времени ответа эндпоинтов в формате, совместимом с Prometheus. Пример метрик для HTTP-запросов:
- `http_request_duration_seconds_sum` — суммарное время ответа для эндпоинта.
- `http_request_duration_seconds_count` — количество запросов к эндпоинту.

Метрики должны содержать лейбл (например, `endpoint`, `path` или `handler`), идентифицирующий эндпоинт.

---

### 2. **Запрос в Prometheus**
Рассчитайте среднее время ответа за день для каждого эндпоинта с помощью PromQL:

```promql
avg_response_time = 
  sum by (endpoint) (increase(http_request_duration_seconds_sum[1d])) 
  / 
  sum by (endpoint) (increase(http_request_duration_seconds_count[1d]))
```

Замените `endpoint` на актуальное название лейбла в ваших метриках.

---

### 3. **Создание графика в Grafana**

#### Вариант 1: Таблица с топ-N медленных эндпоинтов
1. Создайте новую панель в Grafana, выберите тип **Table**.
2. В разделе запросов (Query) укажите:
   ```promql
   topk(5,
     sum by (endpoint) (increase(http_request_duration_seconds_sum[1d])) 
     / 
     sum by (endpoint) (increase(http_request_duration_seconds_count[1d]))
   )
   ```
3. Настройте:
    - **Legend:** `{{endpoint}}` (для отображения названий эндпоинтов).
    - **Sort:** По убыванию значения.
4. Включите опцию **Instant**, чтобы запрос возвращал текущие значения.

#### Вариант 2: Bar chart для визуализации
1. Выберите тип визуализации **Bar chart**.
2. Используйте тот же запрос, что и для таблицы.
3. Настройте ось Y (единицы измерения — секунды) и легенду.

---

### 4. **Оптимизация и дополнения**
- **Динамический период:** Используйте переменную `$__range` в Grafana, чтобы период (например, `[1d]`) автоматически подстраивался под выбранный временной диапазон.
- **Фильтрация эндпоинтов:** Добавьте фильтры (например, исключите статические ресурсы):
  ```promql
  avg_response_time{endpoint!~"/static/.*"}
  ```
- **Временной график:** Для отображения изменений среднего времени за несколько дней используйте:
  ```promql
  sum by (endpoint) (rate(http_request_duration_seconds_sum[$__range])) 
  / 
  sum by (endpoint) (rate(http_request_duration_seconds_count[$__range]))
  ```

---

### 5. **Проверка**

Убедитесь, что:
- Prometheus правильно собирает метрики (проверьте вкладку **Graph** в Prometheus).
- Лейблы эндпоинтов заполнены корректно.
- Временной диапазон в Grafana соответствует желаемому (например, последние 24 часа).

Если все настроено верно, графики будут отображать топ медленных эндпоинтов, что поможет оптимизировать производительность.
